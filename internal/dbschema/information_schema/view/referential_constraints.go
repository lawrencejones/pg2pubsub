//
// Code generated by go-jet DO NOT EDIT.
//
// WARNING: Changes to this file may cause incorrect behavior
// and will be lost if the code is regenerated
//

package view

import (
	"github.com/go-jet/jet/v2/postgres"
)

var ReferentialConstraints = newReferentialConstraintsTable()

type referentialConstraintsTable struct {
	postgres.Table

	//Columns
	ConstraintCatalog       postgres.ColumnString
	ConstraintSchema        postgres.ColumnString
	ConstraintName          postgres.ColumnString
	UniqueConstraintCatalog postgres.ColumnString
	UniqueConstraintSchema  postgres.ColumnString
	UniqueConstraintName    postgres.ColumnString
	MatchOption             postgres.ColumnString
	UpdateRule              postgres.ColumnString
	DeleteRule              postgres.ColumnString

	AllColumns     postgres.ColumnList
	MutableColumns postgres.ColumnList
}

type ReferentialConstraintsTable struct {
	referentialConstraintsTable

	EXCLUDED referentialConstraintsTable
}

// AS creates new ReferentialConstraintsTable with assigned alias
func (a *ReferentialConstraintsTable) AS(alias string) *ReferentialConstraintsTable {
	aliasTable := newReferentialConstraintsTable()
	aliasTable.Table.AS(alias)
	return aliasTable
}

func newReferentialConstraintsTable() *ReferentialConstraintsTable {
	return &ReferentialConstraintsTable{
		referentialConstraintsTable: newReferentialConstraintsTableImpl("information_schema", "referential_constraints"),
		EXCLUDED:                    newReferentialConstraintsTableImpl("", "excluded"),
	}
}

func newReferentialConstraintsTableImpl(schemaName, tableName string) referentialConstraintsTable {
	var (
		ConstraintCatalogColumn       = postgres.StringColumn("constraint_catalog")
		ConstraintSchemaColumn        = postgres.StringColumn("constraint_schema")
		ConstraintNameColumn          = postgres.StringColumn("constraint_name")
		UniqueConstraintCatalogColumn = postgres.StringColumn("unique_constraint_catalog")
		UniqueConstraintSchemaColumn  = postgres.StringColumn("unique_constraint_schema")
		UniqueConstraintNameColumn    = postgres.StringColumn("unique_constraint_name")
		MatchOptionColumn             = postgres.StringColumn("match_option")
		UpdateRuleColumn              = postgres.StringColumn("update_rule")
		DeleteRuleColumn              = postgres.StringColumn("delete_rule")
		allColumns                    = postgres.ColumnList{ConstraintCatalogColumn, ConstraintSchemaColumn, ConstraintNameColumn, UniqueConstraintCatalogColumn, UniqueConstraintSchemaColumn, UniqueConstraintNameColumn, MatchOptionColumn, UpdateRuleColumn, DeleteRuleColumn}
		mutableColumns                = postgres.ColumnList{ConstraintCatalogColumn, ConstraintSchemaColumn, ConstraintNameColumn, UniqueConstraintCatalogColumn, UniqueConstraintSchemaColumn, UniqueConstraintNameColumn, MatchOptionColumn, UpdateRuleColumn, DeleteRuleColumn}
	)

	return referentialConstraintsTable{
		Table: postgres.NewTable(schemaName, tableName, allColumns...),

		//Columns
		ConstraintCatalog:       ConstraintCatalogColumn,
		ConstraintSchema:        ConstraintSchemaColumn,
		ConstraintName:          ConstraintNameColumn,
		UniqueConstraintCatalog: UniqueConstraintCatalogColumn,
		UniqueConstraintSchema:  UniqueConstraintSchemaColumn,
		UniqueConstraintName:    UniqueConstraintNameColumn,
		MatchOption:             MatchOptionColumn,
		UpdateRule:              UpdateRuleColumn,
		DeleteRule:              DeleteRuleColumn,

		AllColumns:     allColumns,
		MutableColumns: mutableColumns,
	}
}
